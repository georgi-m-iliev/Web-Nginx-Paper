<h3>Среда на възникване и причини за поява</h3>
<p>Nginx е създаден с конкретната цел да предостави по-висока производителност от тази на Apache. Основната пречка пред
    уеб сървърите в периода на 2000-те е справянето с висок брой едновременни връзки (C10K проблем – необходимостта уеб
    сървър да обслужи над 10 000 клиента едновременно). В началото на 2000-те години съществуващите уеб сървъри,
    най-вече Apache, започват да изчерпват възможностите си за мащабируемост и ефективност. Традиционният подход на
    Apache, при който за всяка нова връзка се създава отделен процес или нишка, води до висока консумация на ресурси и
    не е подходящ за съвременния уеб с милиони потребители и постоянно отворени връзки.</p>
<p>В началото интернет се състои от прости HTML страници, които предоставят статично съдържание, което се предава по
    бавни връзки (пр. 14.4 kbps). С разширяването на потребителската база, интернет се развива изключително бързо, като
    се превръща в съвременна глобална комуникационна платформа, използвана от над 5 милиарда души. С нарастването на
    броя на постоянно свързаните устройства – настолни компютри, смартфони, таблети – нуждите от по-сложни, динамични и
    интерактивни уеб услуги също се увеличават. Днес онлайн приложенията често разчитат на постоянни връзки, чрез които
    в реално време се обновява съдържание като новини, съобщения, социални емисии и други.</p>
<p>Един от основните проблеми пред уеб архитектите е и остава конкурентността – възможността да се обслужват голям брой
    потребители едновременно. Съвременните браузъри отварят по 4 до 6 паралелни връзки към даден сайт. Например, ако
    един Apache сървър трябва да изпрати 100 KB страница на клиент със скорост от 80 kbps, предаването може да отнеме
    около 10 секунди. За 1000 такива клиенти това би изисквало над 1 GB допълнителна оперативна памет – сериозен
    ресурсен разход, особено при натоварени сайтове.</p>
<p>Ситуацията се влошава още повече при използването на постоянни HTTP връзки, при които връзката между клиента и
    сървъра остава отворена дълго време, с което се заделят ресурси на сървъра за всеки отделен потребител. В този
    контекст става ясно, че са необходими нови решения, които да осигурят ефективна и икономична работа дори при висока
    едновременност.</p>
<p>Основната философия зад създаването на Nginx е постигане на висока производителност, мащабируемост и ниска консумация
    на ресурси. За разлика от Apache, Nginx използва събитийно-базирана, асинхронна архитектура, която не създава нов
    процес или нишка за всяка заявка, а обработва хиляди връзки в рамките на един работен процес. Това позволява
    стабилна работа дори при екстремно натоварване, с минимално използване на CPU и RAM.</p>
<p>Nginx първоначално е проектиран като допълнение към съществуващите уеб сървъри – например да обслужва статично
    съдържание (HTML, CSS, изображения), като по този начин облекчава натоварването на Apache. В последствие по време на
    разработката са добавени интеграции с приложения чрез FastCGI, uswgi или SCGI протоколи, както и със системи за
    кеширане като memcached. С течение на времето се развива в пълноценен уеб сървър и reverse прокси с поддръжка на
    кеширане, load balancing, HTTPS, gzip компресия, стрийминг и други критични функционалности за съвременните уеб
    приложения.</p>
<p>Още от създаването си, целта на Nginx е да предложи оптимизиран инструмент за модерната мрежова среда – такъв, който
    не само отговаря на високите изисквания за производителност, но и е лесен за внедряване и поддръжка, с отворен код и
    възможност за разширение чрез модули.</p>
<h3>Допълнителни преимущества на Nginx</h3>
<p>Основното предимство на Nginx винаги е било способността му да обработва голям брой едновременни връзки с висока
    производителност и ефективност. Това го прави предпочитан избор за натоварени уеб приложения и мащабни
    инфраструктури. Въпреки това, с развитието на уеб технологиите и архитектурите през последните години, Nginx
    предлага и редица допълнителни предимства, които го утвърждават като ключов компонент в модерната уеб среда.</p>
<p>Широко разпространена е концепцията за разделяне (decoupling) на уеб приложенията от самия уеб сървър. Nginx се
    превръща в идеалния инструмент за изграждане на гъвкава и разширяема архитектура. Докато традиционният LAMP стек
    (Linux, Apache, MySQL, PHP/Python/Perl) доминира дълго време, все по-често този модел се заменя от така наречения
    LEMP стек, където "E" символизира Nginx (от възприетото произношение като “Engine X”). Тази промяна позволява уеб
    сървърът да бъде изнесен в периферията на инфраструктурата и да се фокусира върху ефективното обслужване на трафика,
    докато логиката на приложението се разпределя в отделни слоеве.</p>
<p>Nginx е особено подходящ за тази цел, тъй като предлага множество вградени функционалности, които позволяват
    прехвърлянето на натоварващи задачи от приложния слой към сървъра. Сред тях са:</p>
<ul>
    <li>обработка на едновременни връзки и забавяния с минимално използване на ресурси;</li>
    <li>поддръжка на SSL (HTTPS);</li>
    <li>сервиране на статично съдържание (HTML, CSS, изображения и др.);</li>
    <li>компресия на съдържание (gzip);</li>
    <li>кеширане на отговори;</li>
    <li>ограничаване на честотата на заявки (rate limiting);</li>
    <li>HTTP стрийминг на медийно съдържание.</li>
</ul>
<p>Допълнително, Nginx може да се интегрира директно с NoSQL решения като memcached и Redis, с цел още по-бързо
    обслужване на динамични заявки и поддържане на висока производителност при голям брой потребители.</p>
<p>С нарастващото разнообразие от програмни езици и платформи за разработка, все повече компании променят подхода си към
    разработка и внедряване на уеб услуги. Благодарение на своята лекота и модулност, Nginx успява да се превърне в
    най-използваният уеб сървър, като детронира Apache от първата позиция.</p>
<h3>Поставяне на началото</h3>
<p>Първите редове код на Nginx са написани през 2002 г., а през 2004 г. проектът е пуснат публично под BSD лиценз.
    Оттогава насам, броят на потребителите и общността около Nginx расте постоянно, като приносът на потребителите под
    формата на идеи, доклади за грешки и предложения спомага за непрекъснатото усъвършенстване на софтуера.</p>
<p>Nginx има оригинална кодова база, написана изцяло от нулата на езика C, и е пренесен за множество архитектури и
    операционни системи, включително Linux, FreeBSD, Solaris, macOS и Microsoft Windows. Nginx използва собствени
    библиотеки, като със своите стандартни модули използва почти изцяло и единствено системните C библиотеки, zlib, PCRE
    и OpenSSL. При нужда последните три могат да бъдат изключени при компилиране, като по този начин може да се
    оптимизира още повече производителността или да се избегнат проблеми с лицензните споразумения.</p>
<h3>Събитийно-базирана архитектура и ефективно управление на връзки</h3>
<p>Традиционните уеб сървъри като Apache използват процесно- или нишково-базирани модели за обработка на едновременни
    връзки. При тях всяка нова клиентска заявка се обработва от отделен процес или нишка, които блокират при мрежови или
    входно/изходни операции. Това предполага създаване на собствена среда за изпълнение – включително разпределяне на
    памет за стек и куп, както и допълнително процесорно време за създаване и управление на тези ресурси. При високо
    натоварване тази архитектура води до сериозни загуби на производителност, дължащи се на прекомерно превключване
    между процеси (context switching) и изтощаване на ресурсите. Този подход е резултат от компромис: от една страна,
    осигурява богата функционалност и съвместимост, но от друга – води до ниска ефективност при мащабиране, особено при
    голям брой едновременни потребители.</p>
<p>Още от самото начало Nginx е проектиран като специализиран инструмент, насочен към постигане на максимална
    производителност, гъстота на връзките и икономично използване на системни ресурси. Вместо да следва традиционния
    подход, Nginx използва модулна, събитийно-базирана, асинхронна, еднонишкова и не-блокираща архитектура, която го
    отличава от повечето други уеб сървъри.</p>
<p>В основата на този модел стои механизмът на събитийното известяване и мултиплексирането, които позволяват на Nginx да
    следи хиляди връзки едновременно в рамките на ограничен брой работни процеси, наречени работници (workers). Всеки
    работник е еднонишков и изпълнява оптимизиран цикъл от събития (run-loop), в който се обработват заявки и отговори
    без блокиране и без излишно натоварване на процесора или паметта.</p>
<h3>Модулна структура и вътрешна организация на Nginx</h3>
<p>Една от най-силните страни на Nginx е неговата модулна архитектура, която позволява ефективно разделение на
    отговорностите и лесно разширяване на функционалността без необходимост от промяна в основния код. Всяка заявка,
    която достига до сървъра, преминава през специфични етапи на обработка, като на всеки етап участват различни модули,
    специализирани в дадена задача.</p>
<p>Кодът на работните процеси (<em>workers</em>) в Nginx се състои от ядро (core) и набор от функционални модули. Ядрото
    отговаря за поддържането на строго контролиран <em>run-loop</em> – централен цикъл, в който се следят и обработват
    събития. То извиква съответните части от кода на модулите в точния момент от обработката на заявката. Функционалните
    модули са отговорни за логиката на приложния слой – четене и писане към мрежата и файловата система, преобразуване
    на съдържание, прилагане на сървърни включвания (SSI), проксиране към други сървъри и други.</p>
<p>Системата от модули в Nginx включва различни типове, всеки със своя роля:</p>
<ul>
    <li>Core modules – основни модули, част от ядрото;</li>
    <li>Event modules – отговарят за управление на събития;</li>
    <li>Phase handlers – обработват заявките във всяка фаза;</li>
    <li>Protocol modules – поддържат протоколи като HTTP, HTTPS, SMTP и др.;</li>
    <li>Variable handlers – управляват променливите в конфигурацията;</li>
    <li>Filters – трансформират съдържанието преди изпращане към клиента;</li>
    <li>Upstreams – взаимодействат с външни сървъри (обратен прокси);</li>
    <li>Load balancers – разпределят трафика към различни сървъри.</li>
</ul>
<p>Към момента, модулите в Nginx не се зареждат динамично – те трябва да бъдат компилирани заедно с основния код. В
    бъдещи версии обаче се предвижда поддръжка на зареждащи се модули и ABI, което ще улесни създаването на допълнителни
    разширения.</p>
<p>При обработката на мрежовите заявки и операциите с файлове, Nginx използва оптимизирани механизми за известяване при
    събития и подобрения в работата с входно-изходни операции (I/O). В зависимост от операционната система се използват
    ефективни технологии като epoll (в Linux), kqueue (в BSD) и event ports (в Solaris). Целта е да се предоставят
    възможно най-точни сигнали към операционната система относно състоянието на връзките, трафика, операциите с диска,
    таймаутите и др., което осигурява висока ефективност и ниска латентност.</p>
<figure>
    <img src="img/architecture.png" alt="Архитектура на Nginx" width="600">
    <figcaption>Фигура 1: Архитектура на Nginx</figcaption>
</figure>
<h3>Модел на работа на работните процеси (workers)</h3>
<p>В контекста на високата ефективност и конкурентност, Nginx използва модел на работа на процесите, който избягва
    създаването на отделен процес или нишка за всяка клиентска връзка. Вместо това, един или няколко еднонишкови работни
    процеса (workers) приемат заявки от споделен &bdquo;listening&ldquo; сокет и ги обработват в рамките на високо
    оптимизиран run-loop.</p>
<p>Nginx не разпределя заявките чрез специализиран механизъм, а използва възможностите на ядрото на операционната
    система за това. При стартиране сървърът създава необходимите &bdquo;listening&ldquo; сокети, а работните процесите
    поемат връзките директно, четат, обработват и изпращат отговорите. Основен принцип е максимална асинхронност –
    комуникацията и операциите се извършват с минимално блокиране, използвайки callback функции, събитийни известия и
    прецизни таймери.</p>
<p>Този модел позволява:</p>
<ul>
    <li>минимално използване на памет – без създаване на процеси/нишки на всяка заявка;</li>
    <li>икономия на CPU ресурси – няма непрекъснато създаване и унищожаване на изпълнителни контексти;</li>
    <li>висока стабилност – обработката е непрекъсната и предвидима.</li>
</ul>
<p>Ключова особеност е, че един работен процес може да обслужва хиляди връзки едновременно, като всяка нова връзка
    просто се добавя към цикъла на обработка и се следи асинхронно до приключването ѝ.</p>
<p>Системата е изключително добре мащабируема, особено в многоядрени среди. Обичайна практика е конфигуриране на по един
    работен на всяко ядро, което гарантира оптимално използване на хардуера и предотвратява блокирания и конфликт между
    нишки. Така се избягват ситуации като изчерпване на ресурси и неефективно използване на процесорното време.</p>
<p>Конфигурацията на броя работни процеси зависи от характера на натоварването:</p>
<ul>
    <li>При CPU-интензивни операции (SSL, TCP/IP, компресия) броят на процесите трябва да съответства на броя ядра.</li>
    <li>При дисково-интензивни задачи (статично съдържание, проксиране) може да се използват 1.5 до 2 пъти повече
        работни процеса от броя ядра.</li>
    <li>При системи с множество устройства за съхранение, броят на процесите може да се базира на броя и конфигурацията
        им.</li>
</ul>
<p>Все пак съществуват и някои ограничения на този модел. При недостатъчна производителност на дисковата подсистема
    даден работен процес може да блокира при четене/запис. За да се избегнат подобни блокирания, се препоръчва
    използването на директиви като sendfile и AIO (asynchronous I/O). Една добре планирана инсталация на Nginx трябва да
    отчете обема на данните, наличната памет и характеристиките на дисковия масив.</p>
<p>Друго ограничение е ограничената поддръжка на вградени скриптове (embedded scripting). По подразбиране Nginx поддържа
    само Perl скриптове, и то с предпазливост – защото всяко блокиращо действие или неочаквано излизане от скрипт
    може да спре целия работен процес и да засегне хиляди връзки. Разработката на по-надежден механизъм за скриптове е
    планирана за бъдещи версии.</p>
<h3>Процесни роли в Nginx</h3>
<div class="image-float-container">
    <figure>
        <img id="processes-image" src="img/processes.png" alt="Процесна архитектура на Nginx" width="800">
        <figcaption>Фигура 2: Връзка между видовете процеси на Nginx</figcaption>
    </figure>
</div>
<p>Nginx използва лек и ефективен модел за управление на процесите, който се основава на разделението на отговорностите
    между няколко различни типа процеси. Всички процеси в Nginx са еднонишкови (във версия 1.x) и комуникират помежду си
    чрез споделена памет. При стартиране се създава един главен (master) процес и няколко работни (worker) процеса, също
    така се изпълняват и няколко специални процеса, от които cache loader и cache manager. Главният процес се изпълнява
    като привилегирован потребител, докато работните процеси са непривилегировани.</p>
<p>Главният процес се стартира има следните основни задачи:</p>
<ul>
    <li>чете и валидира конфигурационните файлове;</li>
    <li>създава, свързва и затваря сокети;</li>
    <li>стартира, наблюдава и спира работните процеси;</li>
    <li>прилага промени в конфигурацията без прекъсване на работоспособността;</li>
    <li>управлява постоянни обновявания на изпълнимите файлове (стартира нови такива и се връща към предишна версия при
        нужда);</li>
    <li>отваря повторно лог файловете;</li>
    <li>компилира вградени Perl скриптове.</li>
</ul>
<p>Работните процесите отговарят за:</p>
<ul>
    <li>приемане и обработка на клиентски връзки;</li>
    <li>извършване на проксиране, филтриране и кеширане;</li>
    <li>изпълнение на почти всички функционалности на Nginx.</li>
</ul>
<p>Поради ключовата си роля, именно работните процесите са най-важни за наблюдение от страна на системния администратор
    – те показват реалната оперативна работа на сървъра.</p>
<p>Процесът cache loader има временна роля. При стартиране на сървъра, той:</p>
<ul>
    <li>обхожда директориите със съхранени кеширани файлове;</li>
    <li>валидира и зарежда мета информацията за кеша в паметта;</li>
    <li>приключва, когато всичко е подготвено за нормална работа.</li>
</ul>
<p>Cache manager остава активен през цялото време и има следните отговорности:</p>
<ul>
    <li>изтичане и изчистване на остарели кеширани елементи;</li>
    <li>актуализиране на мета информацията;</li>
    <li>рестартиране при срив, инициирано от главния процеса.</li>
</ul>
<div class="clearfix"></div>